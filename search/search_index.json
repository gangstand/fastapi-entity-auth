{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"FastAPI Entity Auth  <p>Source Code: https://github.com/gangstand/fastapi-entity-auth</p> <p>Documentation: https://gangstand.github.io/fastapi-entity-auth/</p>"},{"location":"#features","title":"Features","text":"<p>A FastAPI extension that provides support for JWT authentication (secure, easy to use, and lightweight).</p> <ul> <li>Access tokens and refresh tokens</li> <li>Freshness Tokens</li> <li>Revoking Tokens</li> <li>Support for WebSocket authorization</li> <li>Support for adding custom claims to JSON Web Tokens</li> <li>Storing tokens in cookies and CSRF protection</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>The easiest way to start working with this extension with pip</p> <pre><code>pip install fastapi-entity-auth\n</code></pre> <p>If you want to use asymmetric (public/private) key signing algorithms, include the cryptography extra requirements. <pre><code>pip install cryptography\n</code></pre></p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#100","title":"1.0.0","text":"<ul> <li>A FastAPI extension that provides support for JWT authentication (secure, easy to use, and lightweight).</li> </ul>"},{"location":"usage/additional-claims/","title":"Additional claims","text":"<p>You may want to store additional information in the access token or refresh token and you could later access in the protected views. This can be done easily by parsing additional information (dictionary python) to parameter user_claims in function create_access_token() or create_refresh_token(), and the data can be accessed later in a protected endpoint with the get_raw_jwt() function.</p> <p>Storing data in the tokens can be good for performance. If you store data in the tokens, you won't need to look it up from disk next time you need it in a protected endpoint. However, you should take care of what data you put in the tokens. Any data in the tokens can be trivially viewed by anyone who can read the tokens.</p> <p>Note: Do not store sensitive information in the tokens!</p> <p>Source Code: https://github.com/gangstand/fastapi-entity-auth/blob/main/examples/additional_claims.py</p> <p>Create a file <code>examples/additional_claims.py</code>:</p> <pre><code>import uvicorn\nfrom fastapi import Depends, FastAPI, HTTPException\nfrom pydantic import BaseModel\n\nfrom fastapi_entity_auth import EntityAuth\n\napp = FastAPI()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass UtilsEntityAuth(EntityAuth):\n    secret_key: str = \"secret\"\n\n\ninstance_auth = UtilsEntityAuth\n\n\n@app.post(\"/login\")\ndef login(data: User, authorize: instance_auth = Depends()) -&gt; dict:\n    if data.username != \"string\" or data.password != \"string\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    # You can be passing custom claim to argument user_claims\n    # in function create_access_token() or create refresh token()\n    another_claims = {\"role\": [\"User\", \"Admin\"]}\n    access_token = authorize.create_access_token(subject=data.username, user_claims=another_claims)\n    return {\"access_token\": access_token}\n\n\n# In protected route, get the claims you added to the jwt with the\n# get_raw_jwt() method\n@app.get(\"/claims\")\ndef user(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_required()\n    return authorize.get_raw_jwt()\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> <p>Running the Server</p> <p>To run the server, execute the following command: <pre><code>$ python examples/basic.py\n</code></pre> This will start the FastAPI server on http://127.0.0.1:8000/.</p>"},{"location":"usage/asymmetric/","title":"Asymmetric Algorithm","text":"<p>Usage of RSA <code>RS*</code> and EC <code>EC*</code> algorithms require a basic understanding of how public-key cryptography is used with regards to digital signatures. If you are familiar with that, you may want to use this.</p> <p>Source Code: https://github.com/gangstand/fastapi-entity-auth/blob/main/examples/asymmetric.py</p> <p>Create a file <code>examples/asymmetric.py</code>:</p> <p><pre><code>import uvicorn\nfrom fastapi import Depends, FastAPI, HTTPException\nfrom pydantic import BaseModel\n\nfrom fastapi_entity_auth import EntityAuth\n\n# In the real case, you can put the\n# public key and private key in *.pem, *.key then you can read that file\nprivate_key = \"\"\"\n-----BEGIN RSA PRIVATE KEY-----\nMIICWwIBAAKBgGBoQhqHdMU65aSBQVC/u9a6HMfKA927aZOk7HA/kXuA5UU4Sl+U\nC9WjDhMQFk1PpqAjZdCqx9ajolTYnIfeaVHcLNpJQ6QXLnUyMnfwPmwYQ2rkuy5w\nI2NdO81CzJ/9S8MsPyMl2/CF9ZxM03eleE8RKFwXCxZ/IoiqN4jVNjSrAgMBAAEC\ngYAnNqEUq146zx8TT6PilWpxB9inByuVaCKkdGPbsG+bfa1D/4Z44/4AUsdpx5Ra\ns/hBkMRcIOsSChMAUe8xcK0DqA9Y7BIVfpma2fH/gYq6dP3dOfCxftZBF00HwIu7\n5e7RWnBC8MkPnrkKdHq6ptAYlGgoSJTEQREqusDiuNG9yQJBAKQib2VhNAqgyvvi\nPdmFrCqq15z9MY16WCfttuqfAaSYKHnZe1WvBKbSNW9x4Cgjfhzl9mlozlW4rob/\nttPN6e0CQQCWXbVtqmVdB5Ol9wQN7DIRc8q5F8HKQqIJAMTmwaRwNDsGRxCWMwGO\n8WAlnejzYTXmrrytv6kXX8U40enJW2X3AkAI42h+5/WmgbCcVVMeHXQGV3wXn0p4\nq+BsQR4/tF6laCwA9TsNl827rvR/1X3bDpj8vaNLcAaEc9zXqK9g5uy9AkATeOkw\n3Xso8/075eRBhU/qkKs1Ew2GiuB+9/mHxJXt7eWi53sPaGWQRFPmKy/qrLEVQZWv\njn1wSHe65vw2lj57AkEAh04n1wrZnCha8s6crMhjggdTXI6G4FU3TGf8ssGboqs3\nj5lemvyKod+u2JVKwarcKmd/gFYBOjsRm18LlZH74A==\n-----END RSA PRIVATE KEY-----\n\"\"\"\npublic_key = \"\"\"\n-----BEGIN PUBLIC KEY-----\nMIGeMA0GCSqGSIb3DQEBAQUAA4GMADCBiAKBgGBoQhqHdMU65aSBQVC/u9a6HMfK\nA927aZOk7HA/kXuA5UU4Sl+UC9WjDhMQFk1PpqAjZdCqx9ajolTYnIfeaVHcLNpJ\nQ6QXLnUyMnfwPmwYQ2rkuy5wI2NdO81CzJ/9S8MsPyMl2/CF9ZxM03eleE8RKFwX\nCxZ/IoiqN4jVNjSrAgMBAAE=\n-----END PUBLIC KEY-----\n\"\"\"\n\napp = FastAPI()\n\n\nclass UtilsEntityAuth(EntityAuth):\n    secret_key: str = \"secret\"\n    algorithm: str = \"RS512\"\n    private_key: str = private_key\n    public_key: str = public_key\n\n\ninstance_auth = UtilsEntityAuth\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\n@app.post(\"/login\")\ndef login(data: User, authorize: instance_auth = Depends()) -&gt; dict:\n    if data.username != \"string\" or data.password != \"string\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    access_token = authorize.create_access_token(subject=data.username)\n    refresh_token = authorize.create_refresh_token(subject=data.username)\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token}\n\n\n@app.post(\"/refresh\")\ndef refresh(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_refresh_token_required()\n\n    current_user = authorize.get_jwt_subject()\n    new_access_token = authorize.create_access_token(subject=current_user)\n    return {\"access_token\": new_access_token}\n\n\n@app.get(\"/protected\")\ndef protected(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_required()\n\n    current_user = authorize.get_jwt_subject()\n    return {\"user\": current_user}\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> Running the Server</p> <p>To run the server, execute the following command: <pre><code>$ python examples/basic.py\n</code></pre> This will start the FastAPI server on http://127.0.0.1:8000/.</p>"},{"location":"usage/basic/","title":"Basic Usage","text":"<p>This example demonstrates the basic usage of FastAPI Entity Auth, a library that simplifies entity-based authentication with FastAPI.</p> <p>Source Code: https://github.com/gangstand/fastapi-entity-auth/blob/main/examples/basic.py</p> <p>Create a file <code>examples/basic.py</code>:</p> <p><pre><code>import uvicorn\nfrom fastapi import Depends, FastAPI, HTTPException\nfrom pydantic import BaseModel\n\nfrom fastapi_entity_auth import EntityAuth\n\napp = FastAPI()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass UtilsEntityAuth(EntityAuth):\n    secret_key: str = \"secret\"\n\n\ninstance_auth = UtilsEntityAuth\n\n\n@app.post(\"/login\")\ndef login(data: User, authorize: instance_auth = Depends()) -&gt; dict:\n    if data.username != \"string\" or data.password != \"string\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n    access_token = authorize.create_access_token(subject=data.username)\n    return {\"access_token\": access_token}\n\n\n@app.get(\"/user\")\ndef user(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_required()\n    current_user = authorize.get_jwt_subject()\n    return {\"user\": current_user}\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> Running the Server</p> <p>To run the server, execute the following command: <pre><code>$ python examples/basic.py\n</code></pre> This will start the FastAPI server on http://127.0.0.1:8000/.</p>"},{"location":"usage/dynamic-algorithm/","title":"Dynamic Token Algorithm","text":"<p>You can specify which algorithm you would like to use to sign the JWT by using the algorithm parameter in create_access_token() or create_refresh_token(). Also you need to specify which algorithms you would like to permit when validating in protected endpoint by settings <code>decode_algorithms</code> which take a sequence. If the JWT doesn't have algorithm in <code>decode_algorithms</code> the token will be rejected.</p> <p>Source Code: https://github.com/gangstand/fastapi-entity-auth/blob/main/examples/dynamic_algorithm.py</p> <p>Create a file <code>examples/dynamic_algorithm.py</code>:</p> <pre><code>import uvicorn\nfrom fastapi import Depends, FastAPI, HTTPException\nfrom pydantic import BaseModel\n\nfrom fastapi_entity_auth import EntityAuth\n\napp = FastAPI()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass UtilsEntityAuth(EntityAuth):\n    secret_key: str = \"secret\"\n    decode_algorithms: set = {\"HS384\", \"HS512\"}\n\n\ninstance_auth = UtilsEntityAuth\n\n\n@app.post(\"/login\")\ndef login(data: User, authorize: instance_auth = Depends()) -&gt; dict:\n    if data.username != \"string\" or data.password != \"string\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    # You can define different algorithm when create a token\n    access_token = authorize.create_access_token(subject=data.username, algorithm=\"HS384\")\n    refresh_token = authorize.create_refresh_token(subject=data.username, algorithm=\"HS512\")\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token}\n\n\n# In protected route, automatically check incoming JWT\n# have algorithm in your `decode_algorithms` or not\n@app.post(\"/refresh\")\ndef refresh(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_refresh_token_required()\n\n    current_user = authorize.get_jwt_subject()\n    new_access_token = authorize.create_access_token(subject=current_user)\n    return {\"access_token\": new_access_token}\n\n\n# In protected route, automatically check incoming JWT\n# have algorithm in your `decode_algorithms` or not\n@app.get(\"/protected\")\ndef protected(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_required()\n\n    current_user = authorize.get_jwt_subject()\n    return {\"user\": current_user}\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> <p>Running the Server</p> <p>To run the server, execute the following command: <pre><code>$ python examples/dynamic_algorithm.py\n</code></pre> This will start the FastAPI server on http://127.0.0.1:8000/.</p>"},{"location":"usage/freshness/","title":"Freshness Tokens","text":"<p>The fresh tokens pattern is built into this extension. This pattern is very simple, you can choose to mark some access tokens as fresh and other as a non-fresh tokens, and use the fresh_jwt_required() function to only allow fresh tokens to access the certain endpoint.</p> <p>This is useful for allowing the fresh tokens to do some critical things (such as update information user) in real case you can see in the GitHub system when user wants to delete a repository in a certain time you need login if tokens not fresh again. Utilizing Fresh tokens in conjunction with refresh tokens can lead to a more secure site, without creating a bad user experience by making users constantly re-authenticate.</p> <p>Here is an example of how you could utilize refresh tokens with the fresh token pattern:</p> <p>Source Code: https://github.com/gangstand/fastapi-entity-auth/blob/main/examples/freshness.py</p> <p>Create a file examples/freshness.py:</p> <p><pre><code>import uvicorn\nfrom fastapi import Depends, FastAPI, HTTPException\nfrom pydantic import BaseModel\n\nfrom fastapi_entity_auth import EntityAuth\n\napp = FastAPI()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass UtilsEntityAuth(EntityAuth):\n    secret_key: str = \"secret\"\n\n\ninstance_auth = UtilsEntityAuth\n\n\n# Standard login endpoint. Will return a fresh access token and a refresh token\n@app.post(\"/login\")\ndef login(data: User, authorize: instance_auth = Depends()) -&gt; dict:\n    if data.username != \"string\" or data.password != \"string\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    \"\"\"\n    create_access_token supports an optional 'fresh' argument,\n    which marks the token as fresh or non-fresh accordingly.\n    As we just verified their username and password, we are\n    going to mark the token as fresh here.\n    \"\"\"\n    access_token = authorize.create_access_token(subject=data.username, fresh=True)\n    refresh_token = authorize.create_refresh_token(subject=data.username)\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token}\n\n\n@app.post(\"/refresh\")\ndef refresh(authorize: instance_auth = Depends()) -&gt; dict:\n    \"\"\"Refresh token endpoint. This will generate a new access token from\n    the refresh token, but will mark that access token as non-fresh,\n    as we do not actually verify a password in this endpoint.\n    \"\"\"\n    authorize.jwt_refresh_token_required()\n\n    current_user = authorize.get_jwt_subject()\n    new_access_token = authorize.create_access_token(subject=current_user, fresh=False)\n    return {\"access_token\": new_access_token}\n\n\n@app.post(\"/fresh-login\")\ndef fresh_login(data: User, authorize: instance_auth = Depends()) -&gt; dict:\n    \"\"\"Fresh login endpoint. This is designed to be used if we need to\n    make a fresh token for a user (by verifying they have the\n    correct username and password). Unlike the standard login endpoint,\n    this will only return a new access token, so that we don't keep\n    generating new refresh tokens, which entirely defeats their point.\n    \"\"\"\n    if data.username != \"string\" or data.password != \"string\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    new_access_token = authorize.create_access_token(subject=data.username, fresh=True)\n    return {\"access_token\": new_access_token}\n\n\n# Any valid JWT access token can access this endpoint\n@app.get(\"/protected\")\ndef protected(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_required()\n\n    current_user = authorize.get_jwt_subject()\n    return {\"user\": current_user}\n\n\n# Only fresh JWT access token can access this endpoint\n@app.get(\"/protected-fresh\")\ndef protected_fresh(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.fresh_jwt_required()\n\n    current_user = authorize.get_jwt_subject()\n    return {\"user\": current_user}\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> Running the Server</p> <p>To run the server, execute the following command: <pre><code>$ python examples/freshness.py\n</code></pre> This will start the FastAPI server on http://127.0.0.1:8000/.</p>"},{"location":"usage/jwt-in-cookies/","title":"JWT in Cookies","text":"<p>Highly recommended using JWT in cookies, if your frontend interacts with the backend, your frontend may be storing JWT in the browser localStorage or sessionStorage. There is nothing wrong with this, but if you have any sort of XSS vulnerability on your site, an attacker will be able to trivially steal your tokens. If you want some additional security on your site, you can save your JWT in an httponly cookies. Which keeps javascript cannot be able to access the cookies.</p> <p>This isn't the full story. However now we can keep our cookies from being stolen via XSS attacks, but session cookies vulnerable to CSRF attacks. To combat CSRF attacks we are going to use a technique called double submit cookie pattern. Double submitting cookies is defined as sending a random value in both a cookie and as a request parameter, with the server verifying if the cookie value and request value are equal.</p> <p>This tokens is saved in a cookie with httponly set to True, so it cannot be accessed via javascript. We will then create a secondary cookie that contains an only random string, but has httponly set to False so that it can be accessed via javascript running on your website.</p> <p>Now in order to access a protected endpoint, you will need to add a custom header that contains the random string in it, and if that header doesn\u2019t exist or it doesn\u2019t match the string that is stored in the JWT, the requester will be kicked out as unauthorized.</p> <p>To break this down, if an attacker attempts to perform a CSRF attack they will send the JWT (via cookie) to protected endpoint, but without the random string in the request headers, they won't be able to access the endpoint. They cannot access the random string unless they can run javascript on your website likely via an XSS attack, and if they are able to perform an XSS attack, they will not be able to steal the actual access and refresh JWT, as javascript is still not able to access those httponly cookies.</p> <p>No system is safe. If an attacker can perform an XSS attack they can still access protected endpoints from people who visit your site. However, it is better than if they were able to steal the access and refresh tokens from local/session storage, and use them whenever they wanted.</p> <p>Source Code: https://github.com/gangstand/fastapi-entity-auth/blob/main/examples/csrf_protection_cookies.py</p> <p>Here is an example of using cookies with CSRF protection:</p> <p><pre><code>import uvicorn\nfrom fastapi import Depends, FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom starlette.middleware.cors import CORSMiddleware\n\nfrom fastapi_entity_auth import EntityAuth\n\n\"\"\"\nBy default, the CRSF cookies will be called csrf_access_token and\ncsrf_refresh_token, and in protected endpoints we will look\nfor the CSRF token in the 'X-CSRF-Token' headers. only certain\nmethods should define CSRF token in headers default is ('POST','PUT','PATCH','DELETE')\n\"\"\"\n\napp = FastAPI()\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass UtilsEntityAuth(EntityAuth):\n    secret_key: str = \"secret\"\n    # Configure application to store and get JWT from cookies\n    token_location: set = {\"cookies\"}\n    # Only allow JWT cookies to be sent over https\n    cookie_secure: bool = False\n    # Enable csrf double submit protection. default is True\n    cookie_csrf_protect: bool = True\n    # Change to 'lax' in production to make your website more secure from CSRF Attacks, default is None\n\n\ninstance_auth = UtilsEntityAuth\n\n\n@app.post(\"/login\")\ndef login(data: User, authorize: instance_auth = Depends()) -&gt; dict:\n    \"\"\"With authjwt_cookie_csrf_protect set to True, set_access_cookies() and\n    set_refresh_cookies() will now also set the non-httponly CSRF cookies.\n    \"\"\"\n    if data.username != \"string\" or data.password != \"string\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    # Create the tokens and passing to set_access_cookies or set_refresh_cookies\n    access_token = authorize.create_access_token(subject=data.username)\n    refresh_token = authorize.create_refresh_token(subject=data.username)\n\n    # Set the JWT and CSRF double submit cookies in the response\n    authorize.set_access_cookies(access_token)\n    authorize.set_refresh_cookies(refresh_token)\n\n    return {\"access\": access_token, \"refresh\": refresh_token}\n\n\n@app.post(\"/refresh\")\ndef refresh(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_refresh_token_required()\n\n    current_user = authorize.get_jwt_subject()\n    new_access_token = authorize.create_access_token(subject=current_user)\n    # Set the JWT and CSRF double submit cookies in the response\n    authorize.set_access_cookies(new_access_token)\n    return {\"msg\": \"The token has been refresh\"}\n\n\n@app.delete(\"/logout\")\ndef logout(authorize: instance_auth = Depends()) -&gt; dict:\n    \"\"\"Because the JWT are stored in an httponly cookie now, we cannot\n    log the user out by simply deleting the cookie in the frontend.\n    We need the backend to send us a response to delete the cookies.\n    \"\"\"\n    authorize.jwt_required()\n\n    authorize.unset_jwt_cookies()\n    return {\"msg\": \"Successfully logout\"}\n\n\n@app.get(\"/protected\")\ndef protected(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_required()\n\n    current_user = authorize.get_jwt_subject()\n    return {\"user\": current_user}\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> Running the Server</p> <p>To run the server, execute the following command: <pre><code>$ python examples/csrf_protection_cookies.py\n</code></pre> This will start the FastAPI server on http://127.0.0.1:8000/.</p>"},{"location":"usage/optional/","title":"Partially Protecting","text":"<p>Source Code: https://github.com/gangstand/fastapi-entity-auth/blob/main/examples/optional.py</p> <p>Create a file <code>examples/optional.py</code>:</p> <p><pre><code>import uvicorn\nfrom fastapi import Depends, FastAPI, HTTPException\nfrom pydantic import BaseModel\n\nfrom fastapi_entity_auth import EntityAuth\n\napp = FastAPI()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass UtilsEntityAuth(EntityAuth):\n    secret_key: str = \"secret\"\n\n\ninstance_auth = UtilsEntityAuth\n\n\n@app.post(\"/login\")\ndef login(data: User, authorize: instance_auth = Depends()) -&gt; dict:\n    if data.username != \"string\" or data.password != \"string\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n    access_token = authorize.create_access_token(subject=data.username)\n    return {\"access_token\": access_token}\n\n\n@app.get(\"/partially-protected\")\ndef partially_protected(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_optional()\n    current_user = authorize.get_jwt_subject() or \"anonymous\"\n    return {\"user\": current_user}\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> Running the Server</p> <p>To run the server, execute the following command: <pre><code>$ python examples/optional.py\n</code></pre> This will start the FastAPI server on http://127.0.0.1:8000/.</p>"},{"location":"usage/refresh/","title":"Refresh Tokens","text":"<p>These are long-lived tokens which can be used to create a new access tokens once an old access token has expired. Refresh tokens cannot access an endpoint that is protected with jwt_required(), jwt_optional(), and fresh_jwt_required() and access tokens cannot access an endpoint that is protected with jwt_refresh_token_required().</p> <p>Utilizing refresh tokens we can help reduce the damage that can be done if an access tokens is stolen. However, if an attacker gets a refresh tokens they can keep generating new access tokens and accessing protected endpoints as though he was that user. We can help combat this by using the fresh tokens pattern, discussed in the next section.</p> <p>Note</p> <p>For accessing /refresh endpoint remember to change access_token with refresh_token in the header <code>Authorization: Bearer &lt;refresh_token&gt;</code></p> <p>Here is an example of using access and refresh tokens:</p> <p>Source Code: https://github.com/gangstand/fastapi-entity-auth/blob/main/examples/refresh.py</p> <p>Create a file examples/refresh.py:</p> <pre><code>import uvicorn\nfrom fastapi import Depends, FastAPI, HTTPException\nfrom pydantic import BaseModel\n\nfrom fastapi_entity_auth import EntityAuth\n\napp = FastAPI()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass UtilsEntityAuth(EntityAuth):\n    secret_key: str = \"secret\"\n\n\ninstance_auth = UtilsEntityAuth\n\n\n@app.post(\"/login\")\ndef login(data: User, authorize: instance_auth = Depends()) -&gt; dict:\n    if data.username != \"string\" or data.password != \"string\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n    access_token = authorize.create_access_token(subject=data.username)\n    return {\"access_token\": access_token}\n\n\n@app.post('/refresh')\ndef refresh(authorize: instance_auth = Depends()):\n    \"\"\"\n    The jwt_refresh_token_required() function insures a valid refresh\n    token is present in the request before running any code below that function.\n    we can use the get_jwt_subject() function to get the subject of the refresh\n    token, and use the create_access_token() function again to make a new access token\n    \"\"\"\n    authorize.jwt_refresh_token_required()\n\n    current_user = authorize.get_jwt_subject()\n    new_access_token = authorize.create_access_token(subject=current_user)\n    return {\"access_token\": new_access_token}\n\n\n@app.get('/protected')\ndef protected(authorize: instance_auth = Depends()):\n    authorize.jwt_required()\n\n    current_user = authorize.get_jwt_subject()\n    return {\"user\": current_user}\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> <p>Running the Server</p> <p>To run the server, execute the following command: <pre><code>$ python examples/refresh.py\n</code></pre> This will start the FastAPI server on http://127.0.0.1:8000/.</p>"},{"location":"usage/revoking/","title":"Revoking Tokens","text":"<p>This will allow you to revoke a specific tokens so that it can no longer access your endpoints. You will have to choose what tokens you want to check against the denylist. Denylist works by providing a callback function to this extension, using the token_in_denylist_loader(). This method will be called whenever the specified tokens (access and/or refresh) is used to access a protected endpoint. If the callback function says that the tokens is revoked, we will not allow the requester to continue, otherwise we will allow the requester to access the endpoint as normal.</p> <p>Here is a basic example use tokens revoking:</p> <p>Source Code: https://github.com/gangstand/fastapi-entity-auth/blob/main/examples/deny_list.py</p> <p><pre><code>import uvicorn\nfrom fastapi import Depends, FastAPI, HTTPException\nfrom pydantic import BaseModel\n\nfrom fastapi_entity_auth import EntityAuth\n\napp = FastAPI()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\n# set deny_list enabled to True\n# you can set to check access or refresh token or even both of them\nclass UtilsEntityAuth(EntityAuth):\n    secret_key: str = \"secret\"\n    deny_list_enabled: bool = True\n    deny_list_token_checks: set = {\"access\", \"refresh\"}\n\n\ninstance_auth = UtilsEntityAuth\n\n# A storage engine to save revoked tokens. in production,\n# you can use Redis for storage system\ndeny_list = set()\n\n\n# For this example, we are just checking if the tokens jti\n# (unique identifier) is in the deny_list set. This could\n# be made more complex, for example storing the token in Redis\n# with the value true if revoked and false if not revoked\n@instance_auth.token_in_deny_list_loader\ndef check_if_token_in_deny_list(decrypted_token: dict) -&gt; bool:\n    jti = decrypted_token[\"jti\"]\n    return jti in deny_list\n\n\n@app.post(\"/login\")\ndef login(data: User, authorize: instance_auth = Depends()) -&gt; dict:\n    if data.username != \"string\" or data.password != \"string\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    access_token = authorize.create_access_token(subject=data.username)\n    refresh_token = authorize.create_refresh_token(subject=data.username)\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token}\n\n\n# Standard refresh endpoint. Token in deny_list will not\n# be able to access this endpoint\n@app.post(\"/refresh\")\ndef refresh(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_refresh_token_required()\n\n    current_user = authorize.get_jwt_subject()\n    new_access_token = authorize.create_access_token(subject=current_user)\n    return {\"access_token\": new_access_token}\n\n\n# Endpoint for revoking the current users access token\n@app.delete(\"/access-revoke\")\ndef access_revoke(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_required()\n\n    jti = authorize.get_raw_jwt()[\"jti\"]\n    deny_list.add(jti)\n    return {\"detail\": \"Access token has been revoke\"}\n\n\n# Endpoint for revoking the current users refresh token\n@app.delete(\"/refresh-revoke\")\ndef refresh_revoke(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_refresh_token_required()\n\n    jti = authorize.get_raw_jwt()[\"jti\"]\n    deny_list.add(jti)\n    return {\"detail\": \"Refresh token has been revoke\"}\n\n\n# A token in deny_list will not be able to access this any more\n@app.get(\"/protected\")\ndef protected(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_required()\n\n    current_user = authorize.get_jwt_subject()\n    return {\"user\": current_user}\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> Running the Server</p> <p>To run the server, execute the following command: <pre><code>$ python examples/deny_list.py\n</code></pre> This will start the FastAPI server on http://127.0.0.1:8000/.</p> <p>In production, you will likely want to use either a database or in-memory store (such as Redis) to store your tokens. Memory stores are great if you are wanting to revoke a tokens when the users log out and you can define timeout to your tokens in Redis, after the timeout has expired, the tokens will automatically be deleted.</p> <p>Here example use Redis for revoking a tokens:</p> <p>Source Code: https://github.com/gangstand/fastapi-entity-auth/blob/main/examples/deny_list_redis.py</p> <p>Note</p> <p>Before that make sure redis already installed on your local machine, you can use docker using this command <code>docker run -d -p 6379:6379 redis</code></p> <p><pre><code>from datetime import timedelta\n\nimport uvicorn\nfrom fastapi import Depends, FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom redis import Redis\n\nfrom fastapi_entity_auth import EntityAuth\n\napp = FastAPI()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\n# set deny_list enabled to True\n# you can set to check access or refresh token or even both of them\nclass UtilsEntityAuth(EntityAuth):\n    secret_key: str = \"secret\"\n    deny_list_enabled: bool = True\n    deny_list_token_checks: set = {\"access\", \"refresh\"}\n    access_token_expires: bool | int | timedelta = timedelta(minutes=60)\n    refresh_token_expires: bool | int | timedelta = timedelta(days=30)\n\n\ninstance_auth = UtilsEntityAuth\n\n# Setup our redis connection for storing the denylist tokens\nredis_conn = Redis(host=\"localhost\", port=6379, db=0, decode_responses=True)\n\n\n# Create our function to check if a token has been revoked. In this simple\n# case, we will just store the tokens jti (unique identifier) in redis.\n# This function will return the revoked status of a token. If a token exists\n# in redis and value is true, token has been revoked\n@instance_auth.token_in_deny_list_loader\ndef check_if_token_in_deny_list(decrypted_token: dict) -&gt; bool:\n    jti = decrypted_token[\"jti\"]\n    entry = redis_conn.get(jti)\n    return entry and entry == \"true\"\n\n\n@app.post(\"/login\")\ndef login(data: User, authorize: instance_auth = Depends()) -&gt; dict:\n    if data.username != \"string\" or data.password != \"string\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n\n    access_token = authorize.create_access_token(subject=data.username)\n    refresh_token = authorize.create_refresh_token(subject=data.username)\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token}\n\n\n# Standard refresh endpoint. Token in deny_list will not\n# be able to access this endpoint\n@app.post(\"/refresh\")\ndef refresh(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_refresh_token_required()\n\n    current_user = authorize.get_jwt_subject()\n    new_access_token = authorize.create_access_token(subject=current_user)\n    return {\"access_token\": new_access_token}\n\n\n# Endpoint for revoking the current users access token\n@app.delete(\"/access-revoke\")\ndef access_revoke(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_required()\n\n    jti = authorize.get_raw_jwt()[\"jti\"]\n    redis_conn.setex(jti, instance_auth.access_token_expires, \"true\")\n    return {\"detail\": \"Access token has been revoke\"}\n\n\n# Endpoint for revoking the current users refresh token\n@app.delete(\"/refresh-revoke\")\ndef refresh_revoke(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_refresh_token_required()\n\n    jti = authorize.get_raw_jwt()[\"jti\"]\n    redis_conn.setex(jti, instance_auth.refresh_token_expires, \"true\")\n    return {\"detail\": \"Refresh token has been revoke\"}\n\n\n# A token in deny_list will not be able to access this any more\n@app.get(\"/protected\")\ndef protected(authorize: instance_auth = Depends()) -&gt; dict:\n    authorize.jwt_required()\n\n    current_user = authorize.get_jwt_subject()\n    return {\"user\": current_user}\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> Running the Server</p> <p>To run the server, execute the following command: <pre><code>$ python examples/deny_list_redis.py\n</code></pre> This will start the FastAPI server on http://127.0.0.1:8000/.</p>"},{"location":"usage/websocket/","title":"WebSocket Protecting","text":"<p>The WebSocket protocol doesn\u2019t handle authorization or authentication. Practically, this means that a WebSocket opened from a page behind auth doesn\u2019t \"automatically\" receive any sort of auth. You need to take steps to also secure the WebSocket connection.</p> <p>Since you cannot customize WebSocket headers from JavaScript, you\u2019re limited to the \"implicit\" auth (i.e. Basic or cookies) that\u2019s sent from the browser. The more common approach to generates a token from your normal HTTP server and then have the client send the token (either as a query string in the WebSocket path or as the first WebSocket message). The WebSocket server then validates that the token is valid.</p> <p>Here is an example of how you authorize from query URL:</p> <p>Source Code: https://github.com/gangstand/fastapi-entity-auth/blob/main/examples/websocket.py</p> <p>Create a file <code>examples/websocket.py</code>:</p> <pre><code>import uvicorn\nfrom fastapi import Depends, FastAPI, HTTPException, Query, WebSocket\nfrom fastapi.responses import HTMLResponse\nfrom pydantic import BaseModel\nfrom starlette.websockets import WebSocketDisconnect\n\nfrom fastapi_entity_auth import EntityAuth\n\napp = FastAPI()\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass UtilsEntityAuth(EntityAuth):\n    secret_key: str = \"secret\"\n\n\ninstance_auth = UtilsEntityAuth\n\n\nclass WebSocketManager:\n    def __init__(self) -&gt; None:\n        self.websocket_connections = set()\n\n    def add_connection(self, websocket: WebSocket) -&gt; None:\n        self.websocket_connections.add(websocket)\n\n    def remove_connection(self, websocket: WebSocket) -&gt; None:\n        self.websocket_connections.remove(websocket)\n\n    async def broadcast(self, message: str) -&gt; None:\n        for connection in self.websocket_connections:\n            await connection.send_text(str(message))\n\n\nwebsocket_manager = WebSocketManager()\n\nhtml = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;authorize&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;WebSocket authorize&lt;/h1&gt;\n        &lt;p&gt;Token:&lt;/p&gt;\n        &lt;textarea id=\"token\" rows=\"4\" cols=\"50\"&gt;&lt;/textarea&gt;&lt;br&gt;&lt;br&gt;\n        &lt;button onclick=\"websocketfun()\"&gt;Send&lt;/button&gt;\n        &lt;ul id='messages'&gt;\n        &lt;/ul&gt;\n        &lt;script&gt;\n            const websocketfun = () =&gt; {\n                let token = document.getElementById(\"token\").value\n                let ws = new WebSocket(`ws://localhost:8000/ws?token=${token}`)\n                ws.onmessage = (event) =&gt; {\n                    let messages = document.getElementById('messages')\n                    let message = document.createElement('li')\n                    let content = document.createTextNode(event.data)\n                    message.appendChild(content)\n                    messages.appendChild(message)\n                }\n            }\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\n\n@app.get(\"/\")\nasync def get() -&gt; HTMLResponse:\n    return HTMLResponse(html)\n\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(\n        websocket: WebSocket,\n        token: str = Query(...),\n        auth: instance_auth = Depends()) -&gt; None:\n    await websocket.accept()\n    try:\n        websocket_manager.add_connection(websocket)\n        auth.jwt_required(auth_from=\"websocket\", token=token)\n        await websocket.send_text(str({\"detail\": \"Successfully Login\"}))\n\n        while True:\n            await websocket.receive_text()\n\n    except WebSocketDisconnect:\n        websocket_manager.remove_connection(websocket)\n    except Exception:\n        websocket_manager.remove_connection(websocket)\n        await websocket.close()\n\n\n@app.post(\"/login\")\ndef login(data: User, authorize: instance_auth = Depends()) -&gt; dict:\n    if data.username != \"string\" or data.password != \"string\":\n        raise HTTPException(status_code=401, detail=\"Bad username or password\")\n    access_token = authorize.create_access_token(subject=data.username, fresh=True)\n    refresh_token = authorize.create_refresh_token(subject=data.username)\n    return {\"access_token\": access_token, \"refresh_token\": refresh_token}\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre> <p>Running the Server</p> <p>To run the server, execute the following command: <pre><code>$ python examples/websocket.py\n</code></pre> This will start the FastAPI server on http://127.0.0.1:8000/.</p>"}]}